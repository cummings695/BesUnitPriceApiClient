//
// InventoryItemDto.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public final class InventoryItemDto: Codable, JSONEncodable, Hashable {

    public var id: Int64?
    public var baseQuantity: Int?
    public var currentQuantity: Int?
    public var orderAmount: Int?
    public var zone: InventoryItemDtoZone?
    public var shelvingUnit: InventoryItemDtoShelvingUnit?
    public var shelfNumber: Int?
    public var active: Bool?
    public var ownerId: Int64?
    public var zoneId: Int64?
    public var shelvingUnitId: Int64?
    public var name: String?
    public var notes: String?
    public var prices: [ProductPriceDto]?
    public var defaultUnitOfMeasureId: Int64?
    public var defaultUnitOfMeasure: UnitDto?
    public var defaultQuantity: Double?
    public var defaultCount: Double?

    public init(id: Int64? = nil, baseQuantity: Int? = nil, currentQuantity: Int? = nil, orderAmount: Int? = nil, zone: InventoryItemDtoZone? = nil, shelvingUnit: InventoryItemDtoShelvingUnit? = nil, shelfNumber: Int? = nil, active: Bool? = nil, ownerId: Int64? = nil, zoneId: Int64? = nil, shelvingUnitId: Int64? = nil, name: String? = nil, notes: String? = nil, prices: [ProductPriceDto]? = nil, defaultUnitOfMeasureId: Int64? = nil, defaultUnitOfMeasure: UnitDto? = nil, defaultQuantity: Double? = nil, defaultCount: Double? = nil) {
        self.id = id
        self.baseQuantity = baseQuantity
        self.currentQuantity = currentQuantity
        self.orderAmount = orderAmount
        self.zone = zone
        self.shelvingUnit = shelvingUnit
        self.shelfNumber = shelfNumber
        self.active = active
        self.ownerId = ownerId
        self.zoneId = zoneId
        self.shelvingUnitId = shelvingUnitId
        self.name = name
        self.notes = notes
        self.prices = prices
        self.defaultUnitOfMeasureId = defaultUnitOfMeasureId
        self.defaultUnitOfMeasure = defaultUnitOfMeasure
        self.defaultQuantity = defaultQuantity
        self.defaultCount = defaultCount
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case baseQuantity
        case currentQuantity
        case orderAmount
        case zone
        case shelvingUnit
        case shelfNumber
        case active
        case ownerId
        case zoneId
        case shelvingUnitId
        case name
        case notes
        case prices
        case defaultUnitOfMeasureId
        case defaultUnitOfMeasure
        case defaultQuantity
        case defaultCount
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(baseQuantity, forKey: .baseQuantity)
        try container.encodeIfPresent(currentQuantity, forKey: .currentQuantity)
        try container.encodeIfPresent(orderAmount, forKey: .orderAmount)
        try container.encodeIfPresent(zone, forKey: .zone)
        try container.encodeIfPresent(shelvingUnit, forKey: .shelvingUnit)
        try container.encodeIfPresent(shelfNumber, forKey: .shelfNumber)
        try container.encodeIfPresent(active, forKey: .active)
        try container.encodeIfPresent(ownerId, forKey: .ownerId)
        try container.encodeIfPresent(zoneId, forKey: .zoneId)
        try container.encodeIfPresent(shelvingUnitId, forKey: .shelvingUnitId)
        try container.encodeIfPresent(name, forKey: .name)
        try container.encodeIfPresent(notes, forKey: .notes)
        try container.encodeIfPresent(prices, forKey: .prices)
        try container.encodeIfPresent(defaultUnitOfMeasureId, forKey: .defaultUnitOfMeasureId)
        try container.encodeIfPresent(defaultUnitOfMeasure, forKey: .defaultUnitOfMeasure)
        try container.encodeIfPresent(defaultQuantity, forKey: .defaultQuantity)
        try container.encodeIfPresent(defaultCount, forKey: .defaultCount)
    }

    public static func == (lhs: InventoryItemDto, rhs: InventoryItemDto) -> Bool {
        lhs.id == rhs.id &&
        lhs.baseQuantity == rhs.baseQuantity &&
        lhs.currentQuantity == rhs.currentQuantity &&
        lhs.orderAmount == rhs.orderAmount &&
        lhs.zone == rhs.zone &&
        lhs.shelvingUnit == rhs.shelvingUnit &&
        lhs.shelfNumber == rhs.shelfNumber &&
        lhs.active == rhs.active &&
        lhs.ownerId == rhs.ownerId &&
        lhs.zoneId == rhs.zoneId &&
        lhs.shelvingUnitId == rhs.shelvingUnitId &&
        lhs.name == rhs.name &&
        lhs.notes == rhs.notes &&
        lhs.prices == rhs.prices &&
        lhs.defaultUnitOfMeasureId == rhs.defaultUnitOfMeasureId &&
        lhs.defaultUnitOfMeasure == rhs.defaultUnitOfMeasure &&
        lhs.defaultQuantity == rhs.defaultQuantity &&
        lhs.defaultCount == rhs.defaultCount
        
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id?.hashValue)
        hasher.combine(baseQuantity?.hashValue)
        hasher.combine(currentQuantity?.hashValue)
        hasher.combine(orderAmount?.hashValue)
        hasher.combine(zone?.hashValue)
        hasher.combine(shelvingUnit?.hashValue)
        hasher.combine(shelfNumber?.hashValue)
        hasher.combine(active?.hashValue)
        hasher.combine(ownerId?.hashValue)
        hasher.combine(zoneId?.hashValue)
        hasher.combine(shelvingUnitId?.hashValue)
        hasher.combine(name?.hashValue)
        hasher.combine(notes?.hashValue)
        hasher.combine(prices?.hashValue)
        hasher.combine(defaultUnitOfMeasureId?.hashValue)
        hasher.combine(defaultUnitOfMeasure?.hashValue)
        hasher.combine(defaultQuantity?.hashValue)
        hasher.combine(defaultCount?.hashValue)
        
    }
}

